<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-04-14">

<title>Noam Finkelstein - Identification of world-model parameters from internet-scale text</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../icon.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Noam Finkelstein</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Identification of world-model parameters from internet-scale text</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 14, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#parameter-identification" id="toc-parameter-identification" class="nav-link active" data-scroll-target="#parameter-identification">Parameter Identification</a></li>
  <li><a href="#the-skeptical-position" id="toc-the-skeptical-position" class="nav-link" data-scroll-target="#the-skeptical-position">The skeptical position</a></li>
  <li><a href="#the-optimistic-position" id="toc-the-optimistic-position" class="nav-link" data-scroll-target="#the-optimistic-position">The optimistic position</a></li>
  <li><a href="#identification-of-how-the-world-works-from-text" id="toc-identification-of-how-the-world-works-from-text" class="nav-link" data-scroll-target="#identification-of-how-the-world-works-from-text">Identification of how the world works from text</a></li>
  <li><a href="#on-the-chinese-room-thought-experiment" id="toc-on-the-chinese-room-thought-experiment" class="nav-link" data-scroll-target="#on-the-chinese-room-thought-experiment">On the Chinese Room thought experiment</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>In statistics, and especially in causal inference, we think a lot about <em>parameter identification</em>. I’ll briefly describe what this means, and reflect a bit on how it relates to the question of what LLMs can learn from text.</p>
<section id="parameter-identification" class="level2">
<h2 class="anchored" data-anchor-id="parameter-identification">Parameter Identification</h2>
<p>Causal inference can be described as the task of taking some <em>observed data</em> and a <em>causal model</em> of the world, and using them to infer the value of a <em>causal parameter</em> of some kind. To take a classic example, in a clinical trial, we have observed data on patient outcomes, and a causal model that says the treatment can affect the outcome, and we’d like to infer the <em>effect</em> of the treatment on the outcome. The treatment effect is a causal parameter, in the sense that it’s a parametric representation of some causal relationship.</p>
<p>The question of <em>identification</em> is the question of whether there’s enough information in the observed data and the causal model to reasonably infer the causal parameter. In the idealized clinical trial, the average treatment effect can be taken to be the simple difference between the average outcomes in the treatment and control groups.</p>
<p>But when we stray from that simple ideal – for example, if patients drop out of the trial, or take a treatment other than the one they were randomly assigned to – it may no longer be possible to infer the average treamtment effect given the observed data and the causal model. In this case, we say the parameter is <em>not identified</em>.</p>
<p>One way to think about parameter identification is as follows. If there is only one possible value of the causal parameter that could lead to the observed data under the causal model, then the parameter is identified. We know it must take that value.</p>
<p>However, if there are multiple values of the parameter that could lead to the observed data under the causal model, then we don’t know which of those values the causal parameter takes. It is not identified.</p>
<p>I think this is useful background for thinking about what it’s possible for large language models, and large vision models, to learn about the world. There’s been a lot of ink spilled over this question; I’ll point out two views close to either end of the spectrum.</p>
</section>
<section id="the-skeptical-position" class="level2">
<h2 class="anchored" data-anchor-id="the-skeptical-position">The skeptical position</h2>
<p>The skeptical position is that LLMs are fundamentally unable to learn about the real world in important ways. This view is well expressed in a <a href="https://aclanthology.org/2020.acl-main.463.pdf">great paper</a> by Emily Bender and Alexander Koller, two prominant NLP researchers. <a href="https://nymag.com/intelligencer/article/ai-artificial-intelligence-chatbots-emily-m-bender.html">This profile</a> of Emily Bender goes through many of the same arguments in a less academic form. I’m hesitant to simplify the argument by summarizing it, so I’d encourage you to read the original paper. That disclaimer aside, I’d characterize the main argument of the paper as follows. There is a fundamental disconnect between text, in the manner an LLM encounters it, and its meaning in the world. Text, as humans encounter it, is always paired with “communicative intent,” relating that text back to the real world. LLMs encounter the text on its own, with no communicative intent – no way to link the text back to the real world. As such it is unable to learn anything beyond statistical linguistic correlations between tokens.</p>
</section>
<section id="the-optimistic-position" class="level2">
<h2 class="anchored" data-anchor-id="the-optimistic-position">The optimistic position</h2>
<p>The optimistic position is that LLMs are capable of generating “world models” from text alone. In other words, the text itself contains enough information to understand what the world must be like, and how the text relates to the world. There’s <a href="https://arxiv.org/pdf/2210.13382.pdf">an interesting paper</a> that makes this argument specifically with reference to the game Othello. Using only textual sequences of Othello moves, the paper presents convincing evidence that an LLM develops an internal model of what the game Othello must be like to generate the observed sequences of moves. The LLM has learned the way the world operates, and therefore can understand and produce the communicative intent associated to each Othello move in the sequence. There are other examples of LLMs learning specific things about “how the world works,” as reflected in careful investigation of their computational processes; we’ll take the Othello example as representative.</p>
<p>A more extreme version of this view was articulated by Ilya Sutskever, chief scientist of OpenAI. He <a href="https://www.youtube.com/watch?v=kZ-e_WtxP64">says</a>:</p>
<blockquote class="blockquote">
<p>It may it may look on the surface that we are just learning statistical correlations in text, but it turns out that to just learn the statistical correlations in text, to compress them really well, what the neural network learns is some representation of the process that produces the text. This text is actually a projection of the world. There is a world out there and it has a projection on this text. And so what the neural network is learning is more and more aspects of the world, of people, of the human condition, their hopes, dreams, and motivations, their interactions and the situations that we are in.</p>
</blockquote>
<p>This claim is along the same lines of the kinds of claims made in the Othello paper linked above, and in other settings with well-defined rules. The claim is that using text alone, the LLM is able to infer what the world must be like in substantial ways. It would follow that the LLM can connect text to meaning, grounded in the relationship of text to the world, and would therefore be capable of communicative intent.</p>
<p>That said, there is at the very least clear difference in degree between Sutskever’s claims and what’s been shown in the research literature. As far as I can tell, humans don’t operate according to a set of rules that can be encoded in neuronal activations. There may be a difference of type as well – the space of <em>possible</em> states of the human world is infinite, unlike in the case of Othello.</p>
<p>It’s also not clear how these kinds of claims could be supported. In the case of Othello and similar games, researchers carefully track and alter neuronal activations within the LLMs to show that the LLM has developed a “mental model” of how the world works, can update its understanding appropriately, and responds as expected when researchers alter it’s mental representation of where things stand. It’s possible to find these mental models because games have states that are simple to represent, and therefore simple for researchers to search for. The othello board has a finite number of squares, and each square has only a small number of possible states. It’s therefore possible to search for neuronal activations that represent the status of each square. What would it look like to make an analogous argument that an LLM has a mental model of people’s “hopes, dreams, and motivations”?</p>
</section>
<section id="identification-of-how-the-world-works-from-text" class="level2">
<h2 class="anchored" data-anchor-id="identification-of-how-the-world-works-from-text">Identification of how the world works from text</h2>
<p>From the causal perspective, this seems like a question about identification. The question is: what rules about how the world works are identified from text data?</p>
<p>We reviewed the basic idea of causal identification above. To roughly adapt the intuition behind identification to this domain, we can say that rules about how the world works are identified if no other set of rules could lead to the observed text data. I do think it would help to have a more formal notion of identification from text, borrowing ideas about “partial identification” from the causal literature as well, but I do not know what this would look like.</p>
<p>Let’s take another look at the Othello example. The rules of Othello are roughly identified from a large enough set of sequences of valid Othello moves. If the rules of Othello were different we would see different sequences of moves, i.e.&nbsp;no other set of rules could have produced the observed data. The same applies in other cases where LLMs have been shown to learn “world models,” or pieces of world models.</p>
<p>Importantly, in the Othello and related examples, the LLM was only given sequences of valid moves. What would have happened if there were invalid moves interspered with the valid moves? In that case, the identification question depends on factors like how often invalid moves were presented, whether there was a systematic explanation for the invalid moves, etc.</p>
<p>I also want to point out that the available data matters quite a bit. It’s been shown that LLMs trained on internet-scale data fail at basic tasks of logical reasoning. The internet is full of examples of invalid logical moves, for reasons of humor, sarcasm, and illogic. My strong suspicion is that an LLM trained exclusively on text representing valid reasoning would learn the rules of logic. Identification, in this case as in Othello, follows from the presence of all and only valid logical moves.</p>
<p>My strong intuition is that human “hopes, dreams, and motivations” are not identified from internet-level text data, for any reasonable interpretation of that phrase. These are fundamentally different kinds of concepts than those for which I think there are reasonable (or demonstrated) identification arguments. That said, I do think formalizing the identification question and the identification claim would be an interesting and illuminating exercise.</p>
<p>Finally, there’s the question of whether a “mental model,” as characterized by identifiable patterns of neuronal activation that map roughly to states of the world, is sufficient to overcome Bender &amp; Koller’s critique re: the disconnect between the manner it which an LLM encounters text, and the original relationship between that text and the world. One way to approach this question is to point out that there’s a long history in philosophy of questioning the space between the real world and our perception of it. At some level, this space is unbridgable even for humans, and so of course it will remain at least as unbridgable for LLMs. I don’t see any reason to think that it’s impossible for LLMs to develop a link to connect text to (identified parts of) the world from text alone, in the same way that we do the same from text and sense. Of course the nature of that connection might be different.</p>
</section>
<section id="on-the-chinese-room-thought-experiment" class="level2">
<h2 class="anchored" data-anchor-id="on-the-chinese-room-thought-experiment">On the Chinese Room thought experiment</h2>
<p>Jonh Searle’s famous <a href="https://en.wikipedia.org/wiki/Chinese_room">chinese room</a> thought experiment is about the question of whether a computer can be said to understand Chinese. The thought experiment suggests that an algorithm for producing a convincing conversation in Chinese can be executed manually by a person, given enough time. Because the person executing the algorithm would not understand Chinese, the computer executing the exact same algorithm, taking the exact same steps, would also not understand Chinese.</p>
<p>I like this thought experiment, but I don’t think the interpretation is straightforward. A human manually executing the set of instructions that define an LLM would be doing multiplication by hand until the end of time. They would only see the result of each multiplication as it comes up, and not hold it all “in memory” in the same way a machine does.</p>
<p>In some sense, I think the conclusion that the algorithm does not understand Chinese is a stretch, given the premise. A person executing an algorithm by hand is executing it very differently than a machine does, and therefore has a different experience of the execution, to the degree that it’s possible to claim they are not really doing the same thing at all. The experience of execution might matter a lot.</p>
<p>Think about, for example, an experienced mountaineer and a novice following exactly the same path and directions through the mountains. They’ll take all the same steps, to the level of abstraction that the steps are specified, but they’ll have very different subjective experiences of taking those steps, and likewise different understandings of their experiences. In the same way, a machine and a human could have very different subjective experiences of executing an algorithm. To say that the machine can’t have a subjective experience at all is begging the question.</p>
<p>The thought experiment, to me, shows that a human can’t understand Chinese in the way an LLM might understand Chinese. But it doesn’t show that an LLM can’t understand Chinese, for some reasonable definition of understanding. And actually, it doesn’t even show that an LLM can’t understand Chinese in the same way a human does (it just shows the inverse).</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>I don’t know what it’s possible for a language model to learn. My intuition sits somewhere between the two extremes of the spectrum.</p>
<p>I don’t think the idea that there is a necessary disconnect between text and the true world is any more convincing than the idea that there’s a necessary disconnect between sense and the world. If facts or rules in the true world are identified from text, then an LLM can in theory reconstruct relevant parts of the world, and use that knowledge to interpret text. This seems structurally similar to the way that humans infer facts and rules about the world from our senses, and then use what we’ve inferred to interpret future inputs.</p>
<p>At the same time, it’s clear that grand claims about what LLMs “understand” are being made with little to back them up.</p>
<p>My suggestion is to develop an identification theory of what is even learnable about the world through text, under which assumptions, and so on. Unlike in the case of causal inference, I don’t think this theory would be purely mathematical, but it would have a strong mathematical component. I’ve tried to show above how such a theory might make sense of the evidence we’ve seen so far about where and how LLMs have succeeded in building “world models”. I would hope that establishing such a theory would make it easier to figure out where we should land on the spectrum between the LLM skeptics and the LLM optimists.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>